************* Module fix_duplicate_code
fix_duplicate_code.py:205:27: E0001: Parsing failed: 'unterminated string literal (detected at line 205) (fix_duplicate_code, line 205)' (syntax-error)
************* Module client.start
client/start.js:1:1: E0001: Parsing failed: 'invalid syntax (client.start, line 1)' (syntax-error)
************* Module client.websocket-client
client/websocket-client.py:333:8: E0001: Parsing failed: 'unexpected indent (client.websocket-client, line 333)' (syntax-error)
************* Module client.cleanup
client/cleanup.py:27:4: E0001: Parsing failed: 'unexpected indent (client.cleanup, line 27)' (syntax-error)
************* Module client.file-sync-client
client/file-sync-client.py:485:21: E0001: Parsing failed: 'unterminated string literal (detected at line 485) (client.file-sync-client, line 485)' (syntax-error)
************* Module client.backend.huggingface
client/backend/huggingface.py:124:76: E0001: Parsing failed: 'unterminated string literal (detected at line 124) (client.backend.huggingface, line 124)' (syntax-error)
************* Module client.backend.hugging
client/backend/hugging.py:58:4: E0001: Parsing failed: 'unexpected indent (client.backend.hugging, line 58)' (syntax-error)
************* Module client.frontend.twitchbot
client/frontend/twitchbot.py:27:4: E0001: Parsing failed: 'unexpected indent (client.frontend.twitchbot, line 27)' (syntax-error)
************* Module client.frontend.settings
client/frontend/settings.html:8:53: E0001: Parsing failed: 'invalid decimal literal (client.frontend.settings, line 8)' (syntax-error)
************* Module client.frontend.logmanager
client/frontend/logmanager.js:1:1: E0001: Parsing failed: 'invalid syntax (client.frontend.logmanager, line 1)' (syntax-error)
************* Module client.frontend.config
client/frontend/config.py:37:4: E0001: Parsing failed: 'unexpected indent (client.frontend.config, line 37)' (syntax-error)
************* Module client.frontend.preload
client/frontend/preload.js:1:1: E0001: Parsing failed: 'invalid syntax (client.frontend.preload, line 1)' (syntax-error)
************* Module client.frontend.importexport
client/frontend/importexport.js:1:7: E0001: Parsing failed: 'invalid syntax (client.frontend.importexport, line 1)' (syntax-error)
************* Module client.frontend.index
client/frontend/index.html:29:44: E0001: Parsing failed: 'invalid decimal literal (client.frontend.index, line 29)' (syntax-error)
************* Module client.frontend.gemini-api-setup
client/frontend/gemini-api-setup.js:1:7: E0001: Parsing failed: 'invalid syntax (client.frontend.gemini-api-setup, line 1)' (syntax-error)
************* Module client.frontend.main
client/frontend/main.js:1:1: E0001: Parsing failed: 'invalid syntax (client.frontend.main, line 1)' (syntax-error)
client/frontend/config.js:37:4: E0001: Parsing failed: 'unexpected indent (client.frontend.config, line 37)' (syntax-error)
************* Module client.frontend.log
client/frontend/log.html:1:1: E0001: Parsing failed: 'invalid syntax (client.frontend.log, line 1)' (syntax-error)
************* Module client.frontend.aiineraction
client/frontend/aiineraction.html:9:16: E0001: Parsing failed: 'invalid decimal literal (client.frontend.aiineraction, line 9)' (syntax-error)
************* Module client.frontend.llama
client/frontend/llama.html:9:16: E0001: Parsing failed: 'invalid decimal literal (client.frontend.llama, line 9)' (syntax-error)
************* Module patch.ailinux-alpha-patch-v0.4
patch/ailinux-alpha-patch-v0.4.py:122:29: E0001: Parsing failed: 'unterminated f-string literal (detected at line 122) (patch.ailinux-alpha-patch-v0.4, line 122)' (syntax-error)
************* Module patch.ailinux-alpha-patch-v0.6
patch/ailinux-alpha-patch-v0.6.py:357:36: E0001: Parsing failed: 'unterminated string literal (detected at line 357) (patch.ailinux-alpha-patch-v0.6, line 357)' (syntax-error)
************* Module patch.ailinux-alpha-patch-v0.2
patch/ailinux-alpha-patch-v0.2.py:38:20: E0001: Parsing failed: 'unexpected indent (patch.ailinux-alpha-patch-v0.2, line 38)' (syntax-error)
************* Module patch.ailinux-alpha-patch-v0.5
patch/ailinux-alpha-patch-v0.5.py:142:29: E0001: Parsing failed: 'unterminated f-string literal (detected at line 142) (patch.ailinux-alpha-patch-v0.5, line 142)' (syntax-error)
************* Module patch.ailinux-alpha-patch-v0.7
patch/ailinux-alpha-patch-v0.7.py:229:25: E0001: Parsing failed: 'unterminated f-string literal (detected at line 229) (patch.ailinux-alpha-patch-v0.7, line 229)' (syntax-error)
************* Module patch.ailinux-alpha-patch-v0.1
patch/ailinux-alpha-patch-v0.1.py:213:14: E0001: Parsing failed: 'expected ':' (patch.ailinux-alpha-patch-v0.1, line 213)' (syntax-error)
************* Module patch.ailinux-alpha-patch-v0.8
patch/ailinux-alpha-patch-v0.8.py:215:52: E0001: Parsing failed: 'unterminated string literal (detected at line 215) (patch.ailinux-alpha-patch-v0.8, line 215)' (syntax-error)
************* Module devtools.uploadready
devtools/uploadready.py:126:17: E0001: Parsing failed: 'unterminated string literal (detected at line 126) (devtools.uploadready, line 126)' (syntax-error)
************* Module devtools.fix_duplicate_code
devtools/fix_duplicate_code.py:205:27: E0001: Parsing failed: 'unterminated string literal (detected at line 205) (devtools.fix_duplicate_code, line 205)' (syntax-error)
************* Module devtools.cleanup
devtools/cleanup.py:27:4: E0001: Parsing failed: 'unexpected indent (devtools.cleanup, line 27)' (syntax-error)
************* Module server.backend.websocket-server
server/backend/websocket-server.py:387:21: E0001: Parsing failed: 'unterminated string literal (detected at line 387) (server.backend.websocket-server, line 387)' (syntax-error)
************* Module server.backend.app
server/backend/app.py:298:69: E0001: Parsing failed: 'unterminated string literal (detected at line 298) (server.backend.app, line 298)' (syntax-error)
************* Module server.backend.data_server
server/backend/data_server.py:254:24: E0001: Parsing failed: 'unexpected indent (server.backend.data_server, line 254)' (syntax-error)
************* Module uploadready
uploadready.py:26:0: C0303: Trailing whitespace (trailing-whitespace)
uploadready.py:119:0: C0303: Trailing whitespace (trailing-whitespace)
uploadready.py:127:64: C0303: Trailing whitespace (trailing-whitespace)
uploadready.py:128:56: C0303: Trailing whitespace (trailing-whitespace)
uploadready.py:129:46: C0303: Trailing whitespace (trailing-whitespace)
uploadready.py:131:0: C0303: Trailing whitespace (trailing-whitespace)
uploadready.py:166:0: C0303: Trailing whitespace (trailing-whitespace)
uploadready.py:14:17: W0612: Unused variable 'dirnames' (unused-variable)
uploadready.py:39:0: R0912: Too many branches (14/12) (too-many-branches)
uploadready.py:45:22: W0612: Unused variable 'file_info' (unused-variable)
uploadready.py:50:17: W0612: Unused variable 'dirnames' (unused-variable)
uploadready.py:95:8: W0612: Unused variable 'dirpath' (unused-variable)
uploadready.py:127:21: W1510: 'subprocess.run' used without explicitly defining the value for 'check'. (subprocess-run-check)
uploadready.py:193:15: W0718: Catching too general exception Exception (broad-exception-caught)
uploadready.py:206:15: W0718: Catching too general exception Exception (broad-exception-caught)
uploadready.py:223:15: W0718: Catching too general exception Exception (broad-exception-caught)
************* Module enhanced-pylint-fixer
enhanced-pylint-fixer.py:55:72: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:78:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:132:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:144:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:178:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:181:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:197:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:201:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:203:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:211:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:221:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:225:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:231:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:235:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:244:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:247:0: C0301: Line too long (110/100) (line-too-long)
enhanced-pylint-fixer.py:254:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:266:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:284:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:292:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:300:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:304:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:306:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:310:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:322:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:330:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:338:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:342:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:344:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:354:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:362:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:371:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:377:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:393:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:415:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:419:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:467:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:469:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:486:0: C0301: Line too long (132/100) (line-too-long)
enhanced-pylint-fixer.py:494:0: C0301: Line too long (111/100) (line-too-long)
enhanced-pylint-fixer.py:502:0: C0301: Line too long (108/100) (line-too-long)
enhanced-pylint-fixer.py:524:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:526:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:532:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:542:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:552:0: C0301: Line too long (110/100) (line-too-long)
enhanced-pylint-fixer.py:586:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:590:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:592:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:599:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:612:77: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:620:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:622:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:629:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:632:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:635:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:648:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:651:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:658:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:663:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:675:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:682:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:685:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:693:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:696:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:701:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:713:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:718:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:732:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:743:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:747:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:758:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:766:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:771:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:784:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:796:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:818:0: C0301: Line too long (119/100) (line-too-long)
enhanced-pylint-fixer.py:826:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:844:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:848:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:852:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:855:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:858:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:861:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:871:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:875:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:880:15: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:881:29: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:885:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:889:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:892:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:901:0: C0303: Trailing whitespace (trailing-whitespace)
enhanced-pylint-fixer.py:1:0: C0103: Module name "enhanced-pylint-fixer" doesn't conform to snake_case naming style (invalid-name)
enhanced-pylint-fixer.py:29:0: R0903: Too few public methods (1/2) (too-few-public-methods)
enhanced-pylint-fixer.py:52:0: R0902: Too many instance attributes (10/7) (too-many-instance-attributes)
enhanced-pylint-fixer.py:109:8: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
enhanced-pylint-fixer.py:130:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
enhanced-pylint-fixer.py:141:23: W0718: Catching too general exception Exception (broad-exception-caught)
enhanced-pylint-fixer.py:142:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
enhanced-pylint-fixer.py:155:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
enhanced-pylint-fixer.py:163:19: W0718: Catching too general exception Exception (broad-exception-caught)
enhanced-pylint-fixer.py:160:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
enhanced-pylint-fixer.py:164:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
enhanced-pylint-fixer.py:182:8: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
enhanced-pylint-fixer.py:189:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
enhanced-pylint-fixer.py:215:12: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
enhanced-pylint-fixer.py:192:4: R0911: Too many return statements (9/6) (too-many-return-statements)
enhanced-pylint-fixer.py:247:4: R0911: Too many return statements (7/6) (too-many-return-statements)
enhanced-pylint-fixer.py:247:38: W0613: Unused argument 'issue' (unused-argument)
enhanced-pylint-fixer.py:333:4: R0911: Too many return statements (7/6) (too-many-return-statements)
enhanced-pylint-fixer.py:430:8: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
enhanced-pylint-fixer.py:440:12: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
enhanced-pylint-fixer.py:403:4: R0911: Too many return statements (8/6) (too-many-return-statements)
enhanced-pylint-fixer.py:482:8: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
enhanced-pylint-fixer.py:451:4: R0911: Too many return statements (7/6) (too-many-return-statements)
enhanced-pylint-fixer.py:508:4: R0914: Too many local variables (20/15) (too-many-locals)
enhanced-pylint-fixer.py:508:4: R0911: Too many return statements (7/6) (too-many-return-statements)
enhanced-pylint-fixer.py:508:4: R0912: Too many branches (13/12) (too-many-branches)
enhanced-pylint-fixer.py:684:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
enhanced-pylint-fixer.py:695:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
enhanced-pylint-fixer.py:700:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
enhanced-pylint-fixer.py:708:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
enhanced-pylint-fixer.py:712:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
enhanced-pylint-fixer.py:737:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
enhanced-pylint-fixer.py:742:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
enhanced-pylint-fixer.py:666:4: R0912: Too many branches (22/12) (too-many-branches)
enhanced-pylint-fixer.py:753:14: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
enhanced-pylint-fixer.py:750:4: R0912: Too many branches (14/12) (too-many-branches)
enhanced-pylint-fixer.py:903:11: W0718: Catching too general exception Exception (broad-exception-caught)
enhanced-pylint-fixer.py:905:8: C0415: Import outside toplevel (traceback) (import-outside-toplevel)
enhanced-pylint-fixer.py:26:0: W0611: Unused Tuple imported from typing (unused-import)
************* Module client.alphaos
client/alphaos.py:55:11: W0718: Catching too general exception Exception (broad-exception-caught)
************* Module client.bigfiles
client/bigfiles.py:8:18: E0602: Undefined variable 'directory' (undefined-variable)
client/bigfiles.py:11:37: E0602: Undefined variable 'directory' (undefined-variable)
************* Module client.adjust_hierarchy_with_debugger
client/adjust_hierarchy_with_debugger.py:69:32: E0602: Undefined variable 'base_dir' (undefined-variable)
************* Module client.analyze
client/analyze.py:19:10: E0602: Undefined variable 'log_file_path' (undefined-variable)
client/analyze.py:20:37: E0602: Undefined variable 'root_dir' (undefined-variable)
************* Module client.backend.app
client/backend/app.py:26:11: W1508: os.getenv default type is builtins.int. Expected str or None. (invalid-envvar-default)
client/backend/app.py:92:11: W0718: Catching too general exception Exception (broad-exception-caught)
client/backend/app.py:76:8: W1201: Use lazy % formatting in logging functions (logging-not-lazy)
client/backend/app.py:76:21: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
client/backend/app.py:116:11: W0718: Catching too general exception Exception (broad-exception-caught)
client/backend/app.py:131:11: W0718: Catching too general exception Exception (broad-exception-caught)
client/backend/app.py:153:11: W0718: Catching too general exception Exception (broad-exception-caught)
client/backend/app.py:182:15: W0718: Catching too general exception Exception (broad-exception-caught)
client/backend/app.py:209:15: W0718: Catching too general exception Exception (broad-exception-caught)
client/backend/app.py:187:12: C0415: Import outside toplevel (json) (import-outside-toplevel)
client/backend/app.py:188:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
client/backend/app.py:260:11: W0718: Catching too general exception Exception (broad-exception-caught)
client/backend/app.py:260:4: W0612: Unused variable 'e' (unused-variable)
client/backend/app.py:11:0: W0611: Unused send_from_directory imported from flask (unused-import)
************* Module client.backend.ai_model
client/backend/ai_model.py:49:4: W0107: Unnecessary pass statement (unnecessary-pass)
client/backend/ai_model.py:58:4: W0601: Global variable '_gpt4all_model' undefined at the module level (global-variable-undefined)
client/backend/ai_model.py:59:7: E0601: Using variable '_gpt4all_model' before assignment (used-before-assignment)
client/backend/ai_model.py:96:11: W0718: Catching too general exception Exception (broad-exception-caught)
client/backend/ai_model.py:96:4: W0612: Unused variable 'e' (unused-variable)
client/backend/ai_model.py:107:4: W0601: Global variable '_openai' undefined at the module level (global-variable-undefined)
client/backend/ai_model.py:108:7: E0601: Using variable '_openai' before assignment (used-before-assignment)
client/backend/ai_model.py:121:11: W0718: Catching too general exception Exception (broad-exception-caught)
client/backend/ai_model.py:116:8: C0415: Import outside toplevel (openai) (import-outside-toplevel)
client/backend/ai_model.py:121:4: W0612: Unused variable 'e' (unused-variable)
client/backend/ai_model.py:132:4: W0601: Global variable '_gemini' undefined at the module level (global-variable-undefined)
client/backend/ai_model.py:133:7: E0601: Using variable '_gemini' before assignment (used-before-assignment)
client/backend/ai_model.py:146:11: W0718: Catching too general exception Exception (broad-exception-caught)
client/backend/ai_model.py:141:8: C0415: Import outside toplevel (google.generativeai) (import-outside-toplevel)
client/backend/ai_model.py:146:4: W0612: Unused variable 'e' (unused-variable)
client/backend/ai_model.py:157:4: W0601: Global variable '_huggingface_model' undefined at the module level (global-variable-undefined)
client/backend/ai_model.py:157:4: W0601: Global variable '_huggingface_tokenizer' undefined at the module level (global-variable-undefined)
client/backend/ai_model.py:157:4: W0601: Global variable '_huggingface_pipeline' undefined at the module level (global-variable-undefined)
client/backend/ai_model.py:159:7: E0601: Using variable '_huggingface_pipeline' before assignment (used-before-assignment)
client/backend/ai_model.py:160:15: E0601: Using variable '_huggingface_model' before assignment (used-before-assignment)
client/backend/ai_model.py:160:35: E0601: Using variable '_huggingface_tokenizer' before assignment (used-before-assignment)
client/backend/ai_model.py:205:11: W0718: Catching too general exception Exception (broad-exception-caught)
client/backend/ai_model.py:205:4: W0612: Unused variable 'e' (unused-variable)
client/backend/ai_model.py:210:14: W0621: Redefining name 'model_name' from outer scope (line 505) (redefined-outer-name)
client/backend/ai_model.py:224:4: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
client/backend/ai_model.py:265:0: W0621: Redefining name 'model_name' from outer scope (line 505) (redefined-outer-name)
client/backend/ai_model.py:294:11: W0718: Catching too general exception Exception (broad-exception-caught)
client/backend/ai_model.py:329:4: W0612: Unused variable 'e' (unused-variable)
client/backend/ai_model.py:351:19: E1101: Module 'openai' has no 'ChatCompletion' member (no-member)
client/backend/ai_model.py:366:4: W0612: Unused variable 'e' (unused-variable)
client/backend/ai_model.py:392:4: W0612: Unused variable 'e' (unused-variable)
client/backend/ai_model.py:406:4: W0612: Unused variable 'model' (unused-variable)
client/backend/ai_model.py:406:11: W0612: Unused variable 'tokenizer' (unused-variable)
client/backend/ai_model.py:431:4: W0612: Unused variable 'e' (unused-variable)
client/backend/ai_model.py:442:4: W0621: Redefining name 'models' from outer scope (line 499) (redefined-outer-name)
client/backend/ai_model.py:453:11: W0718: Catching too general exception Exception (broad-exception-caught)
client/backend/ai_model.py:486:11: W0718: Catching too general exception Exception (broad-exception-caught)
client/backend/ai_model.py:509:33: E0602: Undefined variable 'test_log' (undefined-variable)
client/backend/ai_model.py:10:0: W0611: Unused Union imported from typing (unused-import)
************* Module client.backend.gpt4all.app
client/backend/gpt4all/app.py:6:0: W0105: String statement has no effect (pointless-string-statement)
client/backend/gpt4all/app.py:12:0: C0413: Import "import importlib.metadata" should be placed at the top of the module (wrong-import-position)
client/backend/gpt4all/app.py:13:0: C0413: Import "import io" should be placed at the top of the module (wrong-import-position)
client/backend/gpt4all/app.py:14:0: C0413: Import "import sys" should be placed at the top of the module (wrong-import-position)
client/backend/gpt4all/app.py:15:0: C0413: Import "from collections import namedtuple" should be placed at the top of the module (wrong-import-position)
client/backend/gpt4all/app.py:16:0: C0413: Import "from typing_extensions import Annotated" should be placed at the top of the module (wrong-import-position)
client/backend/gpt4all/app.py:18:0: C0413: Import "import typer" should be placed at the top of the module (wrong-import-position)
client/backend/gpt4all/app.py:19:0: C0413: Import "from gpt4all import GPT4All" should be placed at the top of the module (wrong-import-position)
client/backend/gpt4all/app.py:94:8: W0621: Redefining name 'version' from outer scope (line 185) (redefined-outer-name)
client/backend/gpt4all/app.py:98:4: W0702: No exception type(s) specified (bare-except)
************* Module patch.enhanced-pylint-fixer
patch/enhanced-pylint-fixer.py:55:72: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:78:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:132:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:144:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:178:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:181:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:197:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:201:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:203:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:211:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:221:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:225:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:231:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:235:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:244:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:247:0: C0301: Line too long (110/100) (line-too-long)
patch/enhanced-pylint-fixer.py:254:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:266:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:284:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:292:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:300:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:304:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:306:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:310:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:322:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:330:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:338:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:342:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:344:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:354:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:362:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:371:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:377:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:393:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:415:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:419:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:467:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:469:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:486:0: C0301: Line too long (132/100) (line-too-long)
patch/enhanced-pylint-fixer.py:494:0: C0301: Line too long (111/100) (line-too-long)
patch/enhanced-pylint-fixer.py:502:0: C0301: Line too long (108/100) (line-too-long)
patch/enhanced-pylint-fixer.py:524:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:526:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:532:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:542:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:552:0: C0301: Line too long (110/100) (line-too-long)
patch/enhanced-pylint-fixer.py:586:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:590:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:592:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:599:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:612:77: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:620:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:622:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:629:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:632:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:635:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:648:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:651:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:658:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:663:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:675:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:682:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:685:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:693:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:696:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:701:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:713:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:718:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:732:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:743:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:747:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:758:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:766:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:771:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:784:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:796:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:818:0: C0301: Line too long (119/100) (line-too-long)
patch/enhanced-pylint-fixer.py:826:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:844:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:848:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:852:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:855:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:858:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:861:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:871:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:875:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:880:15: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:881:29: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:885:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:889:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:892:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:901:0: C0303: Trailing whitespace (trailing-whitespace)
patch/enhanced-pylint-fixer.py:1:0: C0103: Module name "enhanced-pylint-fixer" doesn't conform to snake_case naming style (invalid-name)
patch/enhanced-pylint-fixer.py:29:0: R0903: Too few public methods (1/2) (too-few-public-methods)
patch/enhanced-pylint-fixer.py:52:0: R0902: Too many instance attributes (10/7) (too-many-instance-attributes)
patch/enhanced-pylint-fixer.py:109:8: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
patch/enhanced-pylint-fixer.py:130:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
patch/enhanced-pylint-fixer.py:141:23: W0718: Catching too general exception Exception (broad-exception-caught)
patch/enhanced-pylint-fixer.py:142:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
patch/enhanced-pylint-fixer.py:155:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
patch/enhanced-pylint-fixer.py:163:19: W0718: Catching too general exception Exception (broad-exception-caught)
patch/enhanced-pylint-fixer.py:160:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
patch/enhanced-pylint-fixer.py:164:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
patch/enhanced-pylint-fixer.py:182:8: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
patch/enhanced-pylint-fixer.py:189:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
patch/enhanced-pylint-fixer.py:215:12: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
patch/enhanced-pylint-fixer.py:192:4: R0911: Too many return statements (9/6) (too-many-return-statements)
patch/enhanced-pylint-fixer.py:247:4: R0911: Too many return statements (7/6) (too-many-return-statements)
patch/enhanced-pylint-fixer.py:247:38: W0613: Unused argument 'issue' (unused-argument)
patch/enhanced-pylint-fixer.py:333:4: R0911: Too many return statements (7/6) (too-many-return-statements)
patch/enhanced-pylint-fixer.py:430:8: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
patch/enhanced-pylint-fixer.py:440:12: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
patch/enhanced-pylint-fixer.py:403:4: R0911: Too many return statements (8/6) (too-many-return-statements)
patch/enhanced-pylint-fixer.py:482:8: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
patch/enhanced-pylint-fixer.py:451:4: R0911: Too many return statements (7/6) (too-many-return-statements)
patch/enhanced-pylint-fixer.py:508:4: R0914: Too many local variables (20/15) (too-many-locals)
patch/enhanced-pylint-fixer.py:508:4: R0911: Too many return statements (7/6) (too-many-return-statements)
patch/enhanced-pylint-fixer.py:508:4: R0912: Too many branches (13/12) (too-many-branches)
patch/enhanced-pylint-fixer.py:684:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
patch/enhanced-pylint-fixer.py:695:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
patch/enhanced-pylint-fixer.py:700:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
patch/enhanced-pylint-fixer.py:708:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
patch/enhanced-pylint-fixer.py:712:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
patch/enhanced-pylint-fixer.py:737:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
patch/enhanced-pylint-fixer.py:742:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
patch/enhanced-pylint-fixer.py:666:4: R0912: Too many branches (22/12) (too-many-branches)
patch/enhanced-pylint-fixer.py:753:14: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
patch/enhanced-pylint-fixer.py:750:4: R0912: Too many branches (14/12) (too-many-branches)
patch/enhanced-pylint-fixer.py:903:11: W0718: Catching too general exception Exception (broad-exception-caught)
patch/enhanced-pylint-fixer.py:905:8: C0415: Import outside toplevel (traceback) (import-outside-toplevel)
patch/enhanced-pylint-fixer.py:26:0: W0611: Unused Tuple imported from typing (unused-import)
************* Module patch.ailinux-alpha-patch-v0.3
patch/ailinux-alpha-patch-v0.3.py:1:0: C0103: Module name "3" doesn't conform to snake_case naming style (invalid-name)
patch/ailinux-alpha-patch-v0.3.py:59:11: W0718: Catching too general exception Exception (broad-exception-caught)
patch/ailinux-alpha-patch-v0.3.py:94:11: W0718: Catching too general exception Exception (broad-exception-caught)
patch/ailinux-alpha-patch-v0.3.py:200:11: W0718: Catching too general exception Exception (broad-exception-caught)
patch/ailinux-alpha-patch-v0.3.py:590:11: W0718: Catching too general exception Exception (broad-exception-caught)
patch/ailinux-alpha-patch-v0.3.py:614:11: W0718: Catching too general exception Exception (broad-exception-caught)
patch/ailinux-alpha-patch-v0.3.py:598:8: C0415: Import outside toplevel (subprocess) (import-outside-toplevel)
patch/ailinux-alpha-patch-v0.3.py:601:17: W1510: 'subprocess.run' used without explicitly defining the value for 'check'. (subprocess-run-check)
patch/ailinux-alpha-patch-v0.3.py:603:8: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
************* Module devtools.bigfiles
devtools/bigfiles.py:8:18: E0602: Undefined variable 'directory' (undefined-variable)
devtools/bigfiles.py:11:37: E0602: Undefined variable 'directory' (undefined-variable)
************* Module devtools.enhanced-pylint-fixer
devtools/enhanced-pylint-fixer.py:55:72: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:78:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:132:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:144:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:178:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:181:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:197:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:201:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:203:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:211:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:221:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:225:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:231:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:235:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:244:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:247:0: C0301: Line too long (110/100) (line-too-long)
devtools/enhanced-pylint-fixer.py:254:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:266:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:284:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:292:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:300:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:304:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:306:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:310:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:322:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:330:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:338:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:342:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:344:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:354:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:362:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:371:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:377:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:393:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:415:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:419:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:467:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:469:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:486:0: C0301: Line too long (132/100) (line-too-long)
devtools/enhanced-pylint-fixer.py:494:0: C0301: Line too long (111/100) (line-too-long)
devtools/enhanced-pylint-fixer.py:502:0: C0301: Line too long (108/100) (line-too-long)
devtools/enhanced-pylint-fixer.py:524:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:526:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:532:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:542:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:552:0: C0301: Line too long (110/100) (line-too-long)
devtools/enhanced-pylint-fixer.py:586:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:590:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:592:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:599:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:612:77: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:620:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:622:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:629:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:632:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:635:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:648:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:651:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:658:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:663:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:675:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:682:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:685:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:693:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:696:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:701:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:713:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:718:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:732:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:743:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:747:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:758:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:766:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:771:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:784:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:796:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:818:0: C0301: Line too long (119/100) (line-too-long)
devtools/enhanced-pylint-fixer.py:826:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:844:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:848:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:852:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:855:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:858:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:861:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:871:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:875:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:880:15: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:881:29: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:885:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:889:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:892:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:901:0: C0303: Trailing whitespace (trailing-whitespace)
devtools/enhanced-pylint-fixer.py:1:0: C0103: Module name "enhanced-pylint-fixer" doesn't conform to snake_case naming style (invalid-name)
devtools/enhanced-pylint-fixer.py:29:0: R0903: Too few public methods (1/2) (too-few-public-methods)
devtools/enhanced-pylint-fixer.py:52:0: R0902: Too many instance attributes (10/7) (too-many-instance-attributes)
devtools/enhanced-pylint-fixer.py:109:8: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
devtools/enhanced-pylint-fixer.py:130:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
devtools/enhanced-pylint-fixer.py:141:23: W0718: Catching too general exception Exception (broad-exception-caught)
devtools/enhanced-pylint-fixer.py:142:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
devtools/enhanced-pylint-fixer.py:155:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
devtools/enhanced-pylint-fixer.py:163:19: W0718: Catching too general exception Exception (broad-exception-caught)
devtools/enhanced-pylint-fixer.py:160:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
devtools/enhanced-pylint-fixer.py:164:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
devtools/enhanced-pylint-fixer.py:182:8: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
devtools/enhanced-pylint-fixer.py:189:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
devtools/enhanced-pylint-fixer.py:215:12: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
devtools/enhanced-pylint-fixer.py:192:4: R0911: Too many return statements (9/6) (too-many-return-statements)
devtools/enhanced-pylint-fixer.py:247:4: R0911: Too many return statements (7/6) (too-many-return-statements)
devtools/enhanced-pylint-fixer.py:247:38: W0613: Unused argument 'issue' (unused-argument)
devtools/enhanced-pylint-fixer.py:333:4: R0911: Too many return statements (7/6) (too-many-return-statements)
devtools/enhanced-pylint-fixer.py:430:8: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
devtools/enhanced-pylint-fixer.py:440:12: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
devtools/enhanced-pylint-fixer.py:403:4: R0911: Too many return statements (8/6) (too-many-return-statements)
devtools/enhanced-pylint-fixer.py:482:8: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
devtools/enhanced-pylint-fixer.py:451:4: R0911: Too many return statements (7/6) (too-many-return-statements)
devtools/enhanced-pylint-fixer.py:508:4: R0914: Too many local variables (20/15) (too-many-locals)
devtools/enhanced-pylint-fixer.py:508:4: R0911: Too many return statements (7/6) (too-many-return-statements)
devtools/enhanced-pylint-fixer.py:508:4: R0912: Too many branches (13/12) (too-many-branches)
devtools/enhanced-pylint-fixer.py:684:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
devtools/enhanced-pylint-fixer.py:695:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
devtools/enhanced-pylint-fixer.py:700:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
devtools/enhanced-pylint-fixer.py:708:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
devtools/enhanced-pylint-fixer.py:712:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
devtools/enhanced-pylint-fixer.py:737:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
devtools/enhanced-pylint-fixer.py:742:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
devtools/enhanced-pylint-fixer.py:666:4: R0912: Too many branches (22/12) (too-many-branches)
devtools/enhanced-pylint-fixer.py:753:14: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
devtools/enhanced-pylint-fixer.py:750:4: R0912: Too many branches (14/12) (too-many-branches)
devtools/enhanced-pylint-fixer.py:903:11: W0718: Catching too general exception Exception (broad-exception-caught)
devtools/enhanced-pylint-fixer.py:905:8: C0415: Import outside toplevel (traceback) (import-outside-toplevel)
devtools/enhanced-pylint-fixer.py:26:0: W0611: Unused Tuple imported from typing (unused-import)
************* Module devtools.adjust_hierarchy_with_debugger
devtools/adjust_hierarchy_with_debugger.py:69:32: E0602: Undefined variable 'base_dir' (undefined-variable)
************* Module devtools.analyze
devtools/analyze.py:19:10: E0602: Undefined variable 'log_file_path' (undefined-variable)
devtools/analyze.py:20:37: E0602: Undefined variable 'root_dir' (undefined-variable)
************* Module server.backend.ai_model
server/backend/ai_model.py:1:1: W0511: TODO: Dieses Modul enthält Code, der in anderen Dateien dupliziert ist. (fixme)
server/backend/ai_model.py:52:4: W0107: Unnecessary pass statement (unnecessary-pass)
server/backend/ai_model.py:61:4: W0601: Global variable '_gpt4all_model' undefined at the module level (global-variable-undefined)
server/backend/ai_model.py:62:7: E0601: Using variable '_gpt4all_model' before assignment (used-before-assignment)
server/backend/ai_model.py:99:11: W0718: Catching too general exception Exception (broad-exception-caught)
server/backend/ai_model.py:99:4: W0612: Unused variable 'e' (unused-variable)
server/backend/ai_model.py:110:4: W0601: Global variable '_openai' undefined at the module level (global-variable-undefined)
server/backend/ai_model.py:111:7: E0601: Using variable '_openai' before assignment (used-before-assignment)
server/backend/ai_model.py:124:11: W0718: Catching too general exception Exception (broad-exception-caught)
server/backend/ai_model.py:119:8: C0415: Import outside toplevel (openai) (import-outside-toplevel)
server/backend/ai_model.py:124:4: W0612: Unused variable 'e' (unused-variable)
server/backend/ai_model.py:135:4: W0601: Global variable '_gemini' undefined at the module level (global-variable-undefined)
server/backend/ai_model.py:136:7: E0601: Using variable '_gemini' before assignment (used-before-assignment)
server/backend/ai_model.py:149:11: W0718: Catching too general exception Exception (broad-exception-caught)
server/backend/ai_model.py:144:8: C0415: Import outside toplevel (google.generativeai) (import-outside-toplevel)
server/backend/ai_model.py:149:4: W0612: Unused variable 'e' (unused-variable)
server/backend/ai_model.py:160:4: W0601: Global variable '_huggingface_model' undefined at the module level (global-variable-undefined)
server/backend/ai_model.py:160:4: W0601: Global variable '_huggingface_tokenizer' undefined at the module level (global-variable-undefined)
server/backend/ai_model.py:160:4: W0601: Global variable '_huggingface_pipeline' undefined at the module level (global-variable-undefined)
server/backend/ai_model.py:162:7: E0601: Using variable '_huggingface_pipeline' before assignment (used-before-assignment)
server/backend/ai_model.py:163:15: E0601: Using variable '_huggingface_model' before assignment (used-before-assignment)
server/backend/ai_model.py:163:35: E0601: Using variable '_huggingface_tokenizer' before assignment (used-before-assignment)
server/backend/ai_model.py:208:11: W0718: Catching too general exception Exception (broad-exception-caught)
server/backend/ai_model.py:208:4: W0612: Unused variable 'e' (unused-variable)
server/backend/ai_model.py:213:14: W0621: Redefining name 'model_name' from outer scope (line 508) (redefined-outer-name)
server/backend/ai_model.py:227:4: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
server/backend/ai_model.py:268:0: W0621: Redefining name 'model_name' from outer scope (line 508) (redefined-outer-name)
server/backend/ai_model.py:297:11: W0718: Catching too general exception Exception (broad-exception-caught)
server/backend/ai_model.py:332:4: W0612: Unused variable 'e' (unused-variable)
server/backend/ai_model.py:354:19: E1101: Module 'openai' has no 'ChatCompletion' member (no-member)
server/backend/ai_model.py:369:4: W0612: Unused variable 'e' (unused-variable)
server/backend/ai_model.py:395:4: W0612: Unused variable 'e' (unused-variable)
server/backend/ai_model.py:409:4: W0612: Unused variable 'model' (unused-variable)
server/backend/ai_model.py:409:11: W0612: Unused variable 'tokenizer' (unused-variable)
server/backend/ai_model.py:434:4: W0612: Unused variable 'e' (unused-variable)
server/backend/ai_model.py:445:4: W0621: Redefining name 'models' from outer scope (line 502) (redefined-outer-name)
server/backend/ai_model.py:456:11: W0718: Catching too general exception Exception (broad-exception-caught)
server/backend/ai_model.py:489:11: W0718: Catching too general exception Exception (broad-exception-caught)
server/backend/ai_model.py:512:33: E0602: Undefined variable 'test_log' (undefined-variable)
server/backend/ai_model.py:13:0: W0611: Unused Union imported from typing (unused-import)
server/backend/ai_model.py:1:0: R0801: Similar lines in 2 files
==enhanced-pylint-fixer:[28:911]
==patch.enhanced-pylint-fixer:[28:911]
class PylintIssue:
    """Represents a pylint issue extracted from the log file."""

    def __init__(self, file_path: str, line_num: int, code: str, message: str):
        """
        Initialize a pylint issue.

        Args:
            file_path: Path to the file with the issue
            line_num: Line number where the issue occurs
            code: Pylint error/warning code (e.g., E0001, C0303)
            message: Description of the issue
        """
        self.file_path = file_path
        self.line_num = line_num
        self.code = code
        self.message = message

    def __repr__(self) -> str:
        """Return a string representation of the issue."""
        return f"{self.file_path}:{self.line_num} [{self.code}] {self.message}"


class CodeFixer:
    """Class for fixing pylint issues in code."""

    def __init__(self, issues: List[PylintIssue], dry_run: bool = False,
                 log_file: Optional[str] = None, verbose: bool = False):
        """
        Initialize the code fixer.

        Args:
            issues: List of pylint issues to fix
            dry_run: If True, don't actually modify files
            log_file: Path to write log output
            verbose: Whether to print detailed logs
        """
        self.issues = issues
        self.dry_run = dry_run
        self.verbose = verbose
        self.file_cache: Dict[str, List[str]] = {}
        self.fixes_applied = 0
        self.skipped_issues = 0
        self.fixed_issues: List[PylintIssue] = []
        self.unfixed_issues: List[PylintIssue] = []
        self.files_modified: List[str] = []

        # Setup logging
        self.logger = logging.getLogger('pylint_fixer')

        # Set log level based on verbose flag
        log_level = logging.DEBUG if verbose else logging.INFO
        self.logger.setLevel(log_level)

        # Console handler
        console = logging.StreamHandler()
        console.setLevel(log_level)
        formatter = logging.Formatter('%(levelname)s: %(message)s')
        console.setFormatter(formatter)
        self.logger.addHandler(console)

        # File handler (if log_file is provided)
        if log_file:
            file_handler = logging.FileHandler(log_file, mode='w')
            file_handler.setLevel(logging.DEBUG)
            file_formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
            file_handler.setFormatter(file_formatter)
            self.logger.addHandler(file_handler)

    def get_file_type(self, file_path: str) -> str:
        """
        Determine the file type based on extension.

        Args:
            file_path: Path to the file

        Returns:
            File type: 'python', 'javascript', 'html', or 'unknown'
        """
        ext = os.path.splitext(file_path)[1].lower()
        if ext == '.py':
            return 'python'
        elif ext == '.js':
            return 'javascript'
        elif ext in ['.html', '.htm']:
            return 'html'
        else:
            return 'unknown'

    def load_file(self, file_path: str) -> List[str]:
        """
        Load a file into the cache if it's not already loaded.

        Args:
            file_path: Path to the file to load

        Returns:
            List of lines from the file
        """
        if file_path not in self.file_cache:
            if not os.path.exists(file_path):
                self.logger.warning(f"File not found: {file_path}")
                return []

            try:
                with open(file_path, 'r', encoding='utf-8') as file:
                    self.file_cache[file_path] = file.readlines()
            except UnicodeDecodeError:
                # Try again with latin-1 encoding if utf-8 fails
                try:
                    with open(file_path, 'r', encoding='latin-1') as file:
                        self.file_cache[file_path] = file.readlines()
                except Exception as e:
                    self.logger.error(f"Cannot read file {file_path}: {str(e)}")
                    return []

        return self.file_cache[file_path]

    def save_file(self, file_path: str) -> None:
        """
        Save the modified file contents.

        Args:
            file_path: Path to the file to save
        """
        if self.dry_run:
            self.logger.info(f"[DRY RUN] Would save {file_path}")
        else:
            try:
                with open(file_path, 'w', encoding='utf-8') as file:
                    file.writelines(self.file_cache[file_path])
                self.logger.info(f"Saved: {file_path}")
                if file_path not in self.files_modified:
                    self.files_modified.append(file_path)
            except Exception as e:
                self.logger.error(f"Error saving {file_path}: {e}")

    def fix_syntax_error(self, issue: PylintIssue) -> bool:
        """
        Fix E0001 syntax errors.

        Args:
            issue: The pylint issue to fix

        Returns:
            True if the issue was fixed, False otherwise
        """
        if "E0001" not in issue.code:
            return False

        # Get file type to apply appropriate fixes
        file_type = self.get_file_type(issue.file_path)

        if file_type == 'python':
            return self.fix_python_syntax_error(issue)
        elif file_type == 'javascript':
            return self.fix_javascript_syntax_error(issue)
        elif file_type == 'html':
            return self.fix_html_syntax_error(issue)
        else:
            self.logger.warning(f"Unknown file type for {issue.file_path}, can't fix syntax error")
            return False

    def fix_python_syntax_error(self, issue: PylintIssue) -> bool:
        """Fix Python-specific syntax errors."""
        lines = self.load_file(issue.file_path)
        if not lines:
            return False

        line_num = issue.line_num
        if line_num > len(lines):
            return False

        line = lines[line_num - 1]

        # Fix 1: String concatenation issues with '+" +'
        if '+" +' in line or '"" +' in line or '=" +' in line:
            fixed_line = line.replace('=" +', '="')
            fixed_line = fixed_line.replace('"" +', '"')
            fixed_line = fixed_line.replace('+" +', '"+')
            lines[line_num - 1] = fixed_line
            return True

        # Fix 2: Issues with invalid string concatenation
        if "invalid syntax" in issue.message and "+" in line:
            # Remove trailing + for string concatenation
            if re.search(r'"\s*\+\s*$', line):
                lines[line_num - 1] = re.sub(r'"\s*\+\s*$', '"', line)
                return True
            elif re.search(r"'\s*\+\s*$", line):
                lines[line_num - 1] = re.sub(r"'\s*\+\s*$", "'", line)
                return True

        # Fix 3: Missing indentation after function/class definition
        if "expected an indented block" in issue.message:
            prev_line = lines[line_num - 2] if line_num > 1 else ""

            if prev_line.rstrip().endswith(':'):
                # Add properly indented pass statement
                indent = len(prev_line) - len(prev_line.lstrip()) + 4
                lines.insert(line_num - 1, ' ' * indent + 'pass\n')
                return True

        # Fix 4: Unterminated string literals
        if "unterminated string literal" in issue.message:
            return self.fix_unterminated_string(issue, lines, line_num, line)

        # Fix 5: Missing try/except/finally blocks
        if "expected 'except' or 'finally' block" in issue.message:
            # Look for unfinished try blocks
            indent_level = len(line) - len(line.lstrip())
            # Add a simple except block
            lines.insert(line_num, ' ' * indent_level + 'except Exception as e:\n')
            lines.insert(line_num + 1, ' ' * (indent_level + 4) + 'pass  # Added by pylint fixer\n')
            return True

        return False

    def fix_unterminated_string(self, issue: PylintIssue, lines: List[str], line_num: int, line: str) -> bool:
        """Fix unterminated string literals more robustly."""
        # Determine quote type (single or double)
        single_quotes = line.count("'")
        double_quotes = line.count('"')
        triple_single = line.count("'''")
        triple_double = line.count('"""')

        # Handle triple-quoted strings differently
        if "'''" in line and triple_single % 2 == 1:
            # Look for the start of an unclosed triple-quoted string
            if re.search(r"'''[^']*$", line):
                lines[line_num - 1] = line.rstrip() + "'''\n"
                return True
        elif '"""' in line and triple_double % 2 == 1:
            # Look for the start of an unclosed triple-quoted string
            if re.search(r'"""[^"]*$', line):
                lines[line_num - 1] = line.rstrip() + '"""\n'
                return True

        # Handle regular strings
        elif single_quotes % 2 == 1:  # Odd number of single quotes
            # Find the position of the last quote
            last_pos = line.rfind("'")
            # Check if it's not escaped
            if last_pos > 0 and line[last_pos-1] != '\\':
                # Add closing quote
                lines[line_num - 1] = line.rstrip() + "'\n"
                return True
        elif double_quotes % 2 == 1:  # Odd number of double quotes
            # Find the position of the last quote
            last_pos = line.rfind('"')
            # Check if it's not escaped
            if last_pos > 0 and line[last_pos-1] != '\\':
                # Add closing quote
                lines[line_num - 1] = line.rstrip() + '"\n'
                return True

        # Handle f-strings and other special string types
        if 'f"' in line and double_quotes % 2 == 1:
            lines[line_num - 1] = line.rstrip() + '"\n'
            return True
        if "f'" in line and single_quotes % 2 == 1:
            lines[line_num - 1] = line.rstrip() + "'\n"
            return True

        return False

    def fix_javascript_syntax_error(self, issue: PylintIssue) -> bool:
        """Fix JavaScript-specific syntax errors."""
        lines = self.load_file(issue.file_path)
        if not lines:
            return False

        line_num = issue.line_num
        if line_num > len(lines):
            return False

        line = lines[line_num - 1]

        # Fix string literals in JavaScript
        if "unterminated string literal" in issue.message:
            return self.fix_unterminated_string(issue, lines, line_num, line)

        # Fix invalid syntax in JavaScript (often template literals)
        if "invalid syntax" in issue.message:
            # Replace JavaScript template literals that pylint misinterprets
            if "`" in line:
                # Template literals with ${} expressions confuse pylint
                # Replace them with regular strings temporarily
                if "${" in line and "}" in line:
                    modified_line = re.sub(r'\${(\w+)}', r'\1', line)
                    modified_line = modified_line.replace('`', '"')
                    lines[line_num - 1] = modified_line
                    return True

            # Fix arrow functions
            if "=>" in line:
                # Arrow functions cause syntax errors in Python
                # Replace with a temporary function
                modified_line = re.sub(r'(\w+)\s*=>\s*{', r'function \1() {', line)
                lines[line_num - 1] = modified_line
                return True

        return False

    def fix_html_syntax_error(self, issue: PylintIssue) -> bool:
        """Fix HTML-specific syntax errors."""
        lines = self.load_file(issue.file_path)
        if not lines:
            return False

        line_num = issue.line_num
        if line_num > len(lines):
            return False

        line = lines[line_num - 1]

        # Fix "invalid decimal literal" - often caused by HTML attributes
        if "invalid decimal literal" in issue.message:
            # HTML IDs with leading digits cause this error in pylint
            if re.search(r'id="\d', line) or re.search(r"id='\d", line):
                # Modify the ID to have a prefix
                modified_line = re.sub(r'(id=")(\d)', r'\1id_\2', line)
                modified_line = re.sub(r"(id=')(\d)", r"\1id_\2", modified_line)
                lines[line_num - 1] = modified_line
                return True

            # Class names with digits can also cause this
            if re.search(r'class="\d', line) or re.search(r"class='\d", line):
                # Modify the class to have a prefix
                modified_line = re.sub(r'(class=")(\d)', r'\1class_\2', line)
                modified_line = re.sub(r"(class=')(\d)", r"\1class_\2", modified_line)
                lines[line_num - 1] = modified_line
                return True

        # Fix unclosed tags
        if "invalid syntax" in issue.message:
            # Check for unclosed HTML tags
            tag_match = re.search(r'<(\w+)(?:\s+[^>]*)?$', line)
            if tag_match:
                tag_name = tag_match.group(1)
                lines[line_num - 1] = line.rstrip() + f"></{tag_name}>\n"
                return True

            # Check for unclosed HTML attribute quotes
            attr_match = re.search(r'(\w+)="([^"]*$)', line)
            if attr_match:
                lines[line_num - 1] = line.rstrip() + '"\n'
                return True

        return False

    def fix_trailing_whitespace(self, issue: PylintIssue) -> bool:
        """
        Remove trailing whitespace (C0303).

        Args:
            issue: The pylint issue to fix

        Returns:
            True if the issue was fixed, False otherwise
        """
        lines = self.load_file(issue.file_path)
        if not lines:
            return False

        line = lines[issue.line_num - 1]
        fixed_line = line.rstrip() + '\n'

        if fixed_line != line:
            lines[issue.line_num - 1] = fixed_line
            return True

        return False

    def fix_unused_import(self, issue: PylintIssue) -> bool:
        """
        Remove unused imports (W0611).

        Args:
            issue: The pylint issue to fix

        Returns:
            True if the issue was fixed, False otherwise
        """
        if "Unused import" not in issue.message:
            return False

        lines = self.load_file(issue.file_path)
        if not lines:
            return False

        line = lines[issue.line_num - 1]

        # Extract the unused import name from the message
        match = re.search(r"Unused import (\w+)", issue.message)
        if not match:
            return False

        unused_import = match.group(1)

        # Handle different import styles
        if re.match(rf"^\s*import\s+{unused_import}\s*$", line):
            # Direct import (import unused)
            lines[issue.line_num - 1] = f"# {line.rstrip()}  # removed: {issue.code}\n"
            return True
        elif re.match(rf"^\s*from\s+[\w.]+\s+import\s+{unused_import}\s*$", line):
            # Single import from module (from module import unused)
            lines[issue.line_num - 1] = f"# {line.rstrip()}  # removed: {issue.code}\n"
            return True
        elif re.search(rf"from\s+[\w.]+\s+import\s+[^,]+,\s*{unused_import}(\s*,|$)", line):
            # Part of a multi-import (from module import used, unused, other)
            if re.search(rf"{unused_import},", line):
                # Unused import followed by comma
                lines[issue.line_num - 1] = line.replace(f"{unused_import}, ", "")
                return True
            elif re.search(rf",\s*{unused_import}", line):
                # Unused import preceded by comma
                lines[issue.line_num - 1] = line.replace(f", {unused_import}", "")
                return True

        return False

    def fix_missing_docstring(self, issue: PylintIssue) -> bool:
        """
        Add missing docstrings (C0111, C0112, C0103).

        Args:
            issue: The pylint issue to fix

        Returns:
            True if the issue was fixed, False otherwise
        """
        if not ("Missing docstring" in issue.message or "docstring" in issue.message.lower()):
            return False

        lines = self.load_file(issue.file_path)
        if not lines:
            return False

        line = lines[issue.line_num - 1]

        # Only fix Python files for docstrings
        if self.get_file_type(issue.file_path) != 'python':
            return False

        # Detect if it's a function, class, or module
        is_func = "function" in issue.message.lower() or "def " in line
        is_class = "class" in issue.message.lower() or "class " in line
        is_module = "module" in issue.message.lower() or issue.line_num == 1

        indent = len(line) - len(line.lstrip())
        indent_str = ' ' * indent

        if is_module and issue.line_num == 1:
            # Module docstring
            module_name = os.path.basename(issue.file_path).replace('.py', '')
            module_name = module_name.replace('_', ' ').title()
            docstring = f'"""{module_name} module for AILinux.\n\nThis module provides functionality for the AILinux system.\n"""\n'
            lines.insert(0, docstring)
            return True
        elif is_func and "def " in line:
            # Function docstring
            func_name = re.search(r'def\s+(\w+)', line)
            if func_name:
                name = func_name.group(1)
                docstring = f'{indent_str}"""\n{indent_str}Description for function {name}.\n{indent_str}"""\n'
                lines.insert(issue.line_num, docstring)
                return True
        elif is_class and "class " in line:
            # Class docstring
            class_name = re.search(r'class\s+(\w+)', line)
            if class_name:
                name = class_name.group(1)
                docstring = f'{indent_str}"""\n{indent_str}Description for class {name}.\n{indent_str}"""\n'
                lines.insert(issue.line_num, docstring)
                return True

        return False

    def fix_line_too_long(self, issue: PylintIssue) -> bool:
        """
        Shorten lines that are too long (C0301).

        Args:
            issue: The pylint issue to fix

        Returns:
            True if the issue was fixed, False otherwise
        """
        if "Line too long" not in issue.message:
            return False

        lines = self.load_file(issue.file_path)
        if not lines:
            return False

        line = lines[issue.line_num - 1]

        # Try to break the line if it's longer than the limit
        match = re.search(r"Line too long \((\d+)/(\d+)\)", issue.message)
        if match:
            current_len = int(match.group(1))
            limit = int(match.group(2))

            if current_len <= limit:
                return False

            # Case 1: Fix string concatenation with "+" at the end of line
            if '+" +' in line:
                # There's already a string concatenation, but it's broken
                fixed_line = line.replace('+" +', '"+\n')
                lines[issue.line_num - 1] = fixed_line
                return True

            # Case 2: Try to break a string
            if '"' in line or "'" in line:
                for quote in ['"', "'"]:
                    pattern = f'({quote}[^{quote}]*{quote})'
                    strings = re.findall(pattern, line)
                    for string in strings:
                        if len(string) > 30:  # Only split long strings
                            indent = len(line) - len(line.lstrip())
                            indent_str = ' ' * (indent + 4)  # Extra indentation
                            replacement = f"{string[0]}" + "\n" + indent_str + f"\"{string[1:-1]}{string[-1]}"
                            new_line = line.replace(string, replacement)
                            lines[issue.line_num - 1] = new_line
                            return True

            # Case 3: Try to break at commas (lists, function parameters)
            if ',' in line and not ('"' in line or "'" in line):  # Avoid breaking inside strings
                parts = line.split(',')
                if len(parts) > 1:
                    indent = len(line) - len(line.lstrip())
                    indent_str = ' ' * indent
                    new_lines = [parts[0] + ',']
                    for part in parts[1:-1]:
                        new_lines.append(indent_str + part.strip() + ',')
                    new_lines.append(indent_str + parts[-1].strip())
                    lines[issue.line_num - 1] = new_lines[0] + '\n'
                    for i, new_line in enumerate(new_lines[1:], start=1):
                        lines.insert(issue.line_num - 1 + i, new_line + '\n')
                    return True

        return False

    def fix_broad_exception(self, issue: PylintIssue) -> bool:
        """
        Fix broad exception catching (W0718).

        Args:
            issue: The pylint issue to fix

        Returns:
            True if the issue was fixed, False otherwise
        """
        if "Catching too general exception" not in issue.message:
            return False

        lines = self.load_file(issue.file_path)
        if not lines:
            return False

        line = lines[issue.line_num - 1]

        # Check if it's a simple 'except:' or 'except Exception:'
        if re.search(r'except\s+Exception\s*:', line):
            # Replace with except (Exception, RuntimeError):
            replaced_line = line.replace('except Exception:', 'except (Exception, RuntimeError):')
            lines[issue.line_num - 1] = replaced_line
            return True

        return False

    def fix_f_string_logging(self, issue: PylintIssue) -> bool:
        """
        Fix f-string usage in logging calls (W1203, W1201).

        Args:
            issue: The pylint issue to fix

        Returns:
            True if the issue was fixed, False otherwise
        """
        if ("lazy % formatting in logging functions" not in issue.message and
            "logging-fstring-interpolation" not in issue.message and
            "logging-not-lazy" not in issue.message):
            return False

        lines = self.load_file(issue.file_path)
        if not lines:
            return False

        line = lines[issue.line_num - 1]

        # Regular expression to find logging calls with f-strings
        match = re.search(r'(logger\.\w+)\(f[\'"](.+?)[\'"](,.+?)?\)', line)
        if match:
            log_call = match.group(1)
            f_string_content = match.group(2)
            args = match.group(3) if match.group(3) else ''

            # Extract variables from f-string
            vars_in_f_string = re.findall(r'{([^}]+)}', f_string_content)

            # Replace f-string with % formatting
            modified_content = re.sub(r'{([^}]+)}', '%s', f_string_content)

            # If variables were found, add them to the args
            if vars_in_f_string:
                var_args = ", ".join(vars_in_f_string)
                if args:
                    # Add variables to existing args
                    new_line = f'{log_call}("{modified_content}", {var_args}{args})'
                else:
                    # Create new args
                    new_line = f'{log_call}("{modified_content}", {var_args})'
            else:
                # No variables found
                new_line = f'{log_call}("{modified_content}"{args})'

            lines[issue.line_num - 1] = line.replace(match.group(0), new_line)
            return True

        # Alternative pattern for logging with f-string without interpolation
        match = re.search(r'(logger\.\w+)\(f[\'"]([^{}]+)[\'"](,.+?)?\)', line)
        if match:
            log_call = match.group(1)
            string_content = match.group(2)
            args = match.group(3) if match.group(3) else ''

            # Simply remove the 'f' prefix since there are no variables
            new_line = f'{log_call}("{string_content}"{args})'
            lines[issue.line_num - 1] = line.replace(match.group(0), new_line)
            return True

        return False

    def fix_issues(self) -> int:
        """
        Fix all found issues and return the number of fixed problems.

        Returns:
            Number of issues fixed
        """
        # Sort issues by file and line number
        self.issues.sort(key=lambda x: (x.file_path, x.line_num))

        # Group issues by file
        issues_by_file: Dict[str, List[PylintIssue]] = {}
        for issue in self.issues:
            if issue.file_path not in issues_by_file:
                issues_by_file[issue.file_path] = []
            issues_by_file[issue.file_path].append(issue)

        # Print summary of issues to fix
        self.logger.info(f"Found {len(self.issues)} issues in {len(issues_by_file)} files")

        # Categorize by file type
        file_types = {}
        for file_path in issues_by_file:
            file_type = self.get_file_type(file_path)
            if file_type not in file_types:
                file_types[file_type] = 0
            file_types[file_type] += 1

        for file_type, count in file_types.items():
            self.logger.info(f"Found {count} files of type: {file_type}")

        # Prioritize critical syntax errors first
        syntax_errors = [issue for issue in self.issues if issue.code == "E0001"]
        if syntax_errors:
            self.logger.info(f"Found {len(syntax_errors)} syntax errors (E0001) to fix first")

        # First pass: Fix only syntax errors
        if syntax_errors:
            for issue in syntax_errors:
                if self.fix_syntax_error(issue):
                    self.fixes_applied += 1
                    self.fixed_issues.append(issue)
                    self.logger.info(f"Fixed syntax error: {issue}")
                else:
                    self.skipped_issues += 1
                    self.unfixed_issues.append(issue)
                    self.logger.warning(f"Could not fix syntax error: {issue}")

        # Second pass: Fix non-syntax errors
        other_issues = [issue for issue in self.issues if issue.code != "E0001"]
        for issue in other_issues:
            fixed = False

            # Apply the appropriate fixer based on the issue code
            if issue.code == "C0303":  # Trailing whitespace
                fixed = self.fix_trailing_whitespace(issue)
            elif issue.code == "W0611":  # Unused import
                fixed = self.fix_unused_import(issue)
            elif issue.code in ["C0111", "C0112", "C0116"]:  # Missing docstring
                fixed = self.fix_missing_docstring(issue)
            elif issue.code == "C0301":  # Line too long
                fixed = self.fix_line_too_long(issue)
            elif issue.code == "W0718":  # Broad exception
                fixed = self.fix_broad_exception(issue)
            elif issue.code in ["W1201", "W1203"]:  # Logging format
                fixed = self.fix_f_string_logging(issue)

            if fixed:
                self.fixes_applied += 1
                self.fixed_issues.append(issue)
                if self.verbose:
                    self.logger.debug(f"Fixed: {issue}")
            else:
                self.skipped_issues += 1
                self.unfixed_issues.append(issue)
                if self.verbose:
                    self.logger.debug(f"Skipped: {issue}")

        # Save all modified files
        for file_path in self.file_cache:
            self.save_file(file_path)

        return self.fixes_applied

    def print_summary(self):
        """Print a summary of the fixes applied."""
        print("\n" + "="*50)
        print(f"SUMMARY:")
        print(f"Total issues processed: {len(self.issues)}")
        print(f"Fixed: {self.fixes_applied} issues")
        print(f"Skipped: {self.skipped_issues} issues")
        print(f"Files modified: {len(self.files_modified)}")

        # Group by file type
        file_types = {}
        for file_path in self.files_modified:
            file_type = self.get_file_type(file_path)
            if file_type not in file_types:
                file_types[file_type] = 0
            file_types[file_type] += 1

        if file_types:
            print("\nFixed files by type:")
            for file_type, count in sorted(file_types.items()):
                print(f"  {file_type}: {count} files")

        if self.files_modified:
            print("\nModified files:")
            for file in sorted(self.files_modified):
                print(f"  - {file}")

        # Group fixed issues by type
        if self.fixed_issues:
            fixed_by_code = {}
            for issue in self.fixed_issues:
                if issue.code not in fixed_by_code:
                    fixed_by_code[issue.code] = 0
                fixed_by_code[issue.code] += 1

            print("\nFixed issues by type:")
            for code, count in sorted(fixed_by_code.items(), key=lambda x: x[1], reverse=True):
                print(f"  {code}: {count} issues")

        # Group unfixed issues by type
        if self.unfixed_issues:
            unfixed_by_code = {}
            for issue in self.unfixed_issues:
                if issue.code not in unfixed_by_code:
                    unfixed_by_code[issue.code] = 0
                unfixed_by_code[issue.code] += 1

            print("\nRemaining issues by type:")
            for code, count in sorted(unfixed_by_code.items(), key=lambda x: x[1], reverse=True):
                print(f"  {code}: {count} issues")


def parse_pylint_log(log_path: str) -> List[PylintIssue]:
    """
    Parse the pylint log file and extract issues.

    Args:
        log_path: Path to the pylint log file

    Returns:
        List of parsed pylint issues
    """
    issues = []

    try:
        with open(log_path, 'r', encoding='utf-8') as file:
            for line in file:
                # Typical pylint format: file.py:42:0: C0111: Missing docstring (missing-docstring)
                match = re.match(r'^([\w\./\-]+):(\d+)(?::\d+)?: ([CRWE]\d{4}): (.+?)(?:\s\([\w-]+\))?$', line.strip())
                if match:
                    file_path, line_num, code, message = match.groups()
                    # Make sure the line number is an integer
                    try:
                        line_num = int(line_num)
                    except ValueError:
                        continue

                    issues.append(PylintIssue(
                        file_path=file_path,
                        line_num=line_num,
                        code=code,
                        message=message
                    ))
    except (FileNotFoundError, UnicodeDecodeError) as e:
        print(f"Error reading log file {log_path}: {e}")
        sys.exit(1)

    return issues


def main():
    """Main function to parse arguments and run the fixer."""
    parser = argparse.ArgumentParser(
        description='Fix pylint issues in Python, JavaScript, and HTML files')

    parser.add_argument('--log-file', '-l',
                      help='Path to write detailed log output',
                      default='pylint_fixed.log')

    parser.add_argument('--input-log', '-i',
                      help='Path to the pylint log file (default: optimization.log)',
                      default='optimization.log')

    parser.add_argument('--dry-run', '-d', action='store_true',
                      help='Show changes without applying them')

    parser.add_argument('--verbose', '-v', action='store_true',
                      help='Print detailed output')

    parser.add_argument('--version', action='version',
                      version='%(prog)s 1.0')

    args = parser.parse_args()

    # Check if log file exists
    if not os.path.exists(args.input_log):
        print(f"Error: The pylint log file {args.input_log} does not exist.")
        return 1

    print(f"Analyzing {args.input_log}...")
    issues = parse_pylint_log(args.input_log)

    if not issues:
        print("No issues found in the log file.")
        return 0

    print(f"Found {len(issues)} issues to fix.")

    # Create and run the CodeFixer
    fixer = CodeFixer(
        issues,
        dry_run=args.dry_run,
        log_file=args.log_file,
        verbose=args.verbose
    )

    try:
        # Fix the issues
        fixes_applied = fixer.fix_issues()

        # Print summary
        fixer.print_summary()

        # Print advice
        if fixes_applied > 0:
            print("\nNext steps:")
            print("  1. Run pylint again to see if remaining issues were resolved")
            print("  2. For JavaScript and HTML files, consider using appropriate linters")
            print("     - For JavaScript: ESLint (npm install -g eslint)")
            print("     - For HTML: HTMLHint (npm install -g htmlhint)")
            print("  3. Some issues may require manual fixes - syntax errors have priority")

        return 0
    except Exception as e:
        print(f"Error: {e}")
        import traceback
        traceback.print_exc()
        return 1


if __name__ == "__main__":
    sys.exit(main()) (duplicate-code)
server/backend/ai_model.py:1:0: R0801: Similar lines in 2 files
==client.backend.ai_model:[13:513]
==server.backend.ai_model:[16:516]
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(name)s - %(message)s",
    handlers=[
        logging.FileHandler("ai_model.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("AIModel")

# Load environment variables
load_dotenv()

# Get API keys and model paths from environment
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY", "")
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY", "")
HUGGINGFACE_API_KEY = os.getenv("HUGGINGFACE_API_KEY", "")
LLAMA_MODEL_PATH = os.getenv("LLAMA_MODEL_PATH", "Meta-Llama-3-8B-Instruct.Q4_0.gguf")
DEFAULT_MODEL = os.getenv("DEFAULT_MODEL", "gpt4all")

# Hugging Face model configuration
HUGGINGFACE_MODEL_ID = os.getenv("HUGGINGFACE_MODEL_ID", "mistralai/Mistral-7B-Instruct-v0.2")
CACHE_DIR = os.getenv("HUGGINGFACE_CACHE_DIR", "./models/huggingface")

# Global model instances
_GPT4ALL_MODEL = None
_OPENAI = None
_GEMINI = None
_HUGGINGFACE_PIPELINE = None
_HUGGINGFACE_TOKENIZER = None
_HUGGINGFACE_MODEL = None


class ModelNotInitializedError(Exception):
    """Exception raised when a model cannot be initialized."""
    pass


def initialize_gpt4all():
    """Initialize the GPT4All model for offline processing.

    Returns:
        GPT4All model instance or None if initialization fails
    """
    global _gpt4all_model
    if _gpt4all_model is not None:
        return _gpt4all_model

    try:
        # pylint: disable=C0415  # Import außerhalb des Toplevel
        from gpt4all import GPT4All

        # Check if model exists
        model_path = os.path.expanduser(LLAMA_MODEL_PATH)
        if not os.path.exists(model_path):
            model_dir = os.path.dirname(model_path)
            _filename = os.path.basename(model_path)
            logger.warning("Model file not found at: %smodel_path")
            logger.info("Checking if model exists in directory: %smodel_dir")

            # Check if the directory exists, create if not
            if not os.path.exists(model_dir):
                os.makedirs(model_dir, exist_ok=True)
                logger.info("Created model directory: %smodel_dir")

            # List available models if directory exists
            if os.path.exists(model_dir):
                files = os.listdir(model_dir)
                gguf_files = [f for f in files if f.endswith('.gguf')]
                if gguf_files:
                    # Use the first available .gguf file
                    model_path = os.path.join(model_dir, gguf_files[0])
                    logger.info("Using available model: %smodel_path")
                else:
                    logger.warning("No .gguf models found. Will download the default model.")

            # Model will be downloaded automatically by GPT4All if not found

        logger.info("Loading GPT4All model from: %smodel_path")
        _gpt4all_model = GPT4All(model_path)
        logger.info("GPT4All model loaded successfully")
        return _gpt4all_model
    except Exception as e:
        logger.error("Error initializing GPT4All: %sstr(e)")
        return None


def initialize_openai():
    """Initialize the OpenAI API client.

    Returns:
        OpenAI client object or None if initialization fails
    """
    global _openai
    if _openai is not None:
        return _openai

    if not OPENAI_API_KEY:
        logger.warning("No OpenAI API key found in environment")
        return None

    try:
        import openai
        openai.api_key = OPENAI_API_KEY
        _openai = openai
        logger.info("OpenAI API initialized successfully")
        return _openai
    except Exception as e:
        logger.error("Error initializing OpenAI API: %sstr(e)")
        return None


def initialize_gemini():
    """Initialize the Google Gemini API client.

    Returns:
        Gemini client object or None if initialization fails
    """
    global _gemini
    if _gemini is not None:
        return _gemini

    if not GEMINI_API_KEY:
        logger.warning("No Gemini API key found in environment")
        return None

    try:
        import google.generativeai as genai
        genai.configure(api_key=GEMINI_API_KEY)
        _gemini = genai
        logger.info("Google Gemini API initialized successfully")
        return _gemini
    except Exception as e:
        logger.error("Error initializing Gemini API: %sstr(e)")
        return None


def initialize_huggingface():
    """Initialize the Hugging Face model for inference.

    Returns:
        A tuple of (model, tokenizer, pipeline) or None if initialization fails
    """
    global _huggingface_model, _huggingface_tokenizer, _huggingface_pipeline

    if _huggingface_pipeline is not None:
        return _huggingface_model, _huggingface_tokenizer, _huggingface_pipeline

    try:
        # pylint: disable=C0415  # Import außerhalb des Toplevel
        from transformers import AutoModelForCausalLM, AutoTokenizer, pipeline
        import torch

        # Create cache directory if it doesn't exist
        os.makedirs(CACHE_DIR, exist_ok=True)

        # Check for CUDA availability
        device = "cuda" if torch.cuda.is_available() else "cpu"
        logger.info("Using device: %sdevice for Hugging Face model")

        # Load tokenizer first
        logger.info("Loading Hugging Face tokenizer: %sHUGGINGFACE_MODEL_ID")
        _huggingface_tokenizer = AutoTokenizer.from_pretrained(
            HUGGINGFACE_MODEL_ID,
            cache_dir=CACHE_DIR,
            token=HUGGINGFACE_API_KEY if HUGGINGFACE_API_KEY else None
        )

        # Load model with appropriate configuration
        logger.info("Loading Hugging Face model: %sHUGGINGFACE_MODEL_ID")
        _huggingface_model = AutoModelForCausalLM.from_pretrained(
            HUGGINGFACE_MODEL_ID,
            cache_dir=CACHE_DIR,
            token=HUGGINGFACE_API_KEY if HUGGINGFACE_API_KEY else None,
            torch_dtype=torch.float16 if device == "cuda" else torch.float32,
            low_cpu_mem_usage=True,
            device_map="auto" if device == "cuda" else None
        )

        # Create text generation pipeline
        logger.info("Creating Hugging Face pipeline")
        _huggingface_pipeline = pipeline(
            "text-generation",
            model=_huggingface_model,
            tokenizer=_huggingface_tokenizer,
            device=0 if device == "cuda" else -1
        )

        logger.info("Hugging Face model initialized successfully")
        return _huggingface_model, _huggingface_tokenizer, _huggingface_pipeline

    except Exception as e:
        logger.error("Error initializing Hugging Face model: %sstr(e)")
        return None, None, None


def get_model(model_name: str):
    """Get the requested AI model.

    Args:
        model_name: Name of the model to use ('gpt4all', 'openai', 'gemini', 'huggingface')

    Returns:
        Model instance or None if initialization fails

    Raises:
        ValueError: If an unknown model name is provided
    """
    model_name = model_name.lower()

    if model_name == "gpt4all":
        return initialize_gpt4all()
    elif model_name == "openai":
        return initialize_openai()
    elif model_name == "gemini":
        return initialize_gemini()
    elif model_name == "huggingface":
        return initialize_huggingface()
    else:
        raise ValueError(f"Unknown model: {model_name}")


def create_prompt(log_text: str, instruction: Optional[str] = None) -> str:
    """Create a standardized prompt for log analysis.

    Args:
        log_text: The log text to analyze
        instruction: Optional specific instruction to override default

    Returns:
        Formatted prompt string
    """
    default_instruction = """Analyze the following log and provide insights:
1. Summarize what the log is showing
2. Identify any errors or warnings
3. Suggest potential solutions if problems are found
"""

    instruction = instruction or default_instruction

    return f"""{instruction}

LOG:
{log_text}

ANALYSIS:
"""


def analyze_log(log_text: str,

model_name: str = DEFAULT_MODEL,
instruction: Optional[str] = None) -> str:
    """Analyze log text using the specified AI model.

    Args:
        log_text: The log text to analyze
        model_name: Name of the model to use for analysis
        instruction: Optional specific instruction for the model

    Returns:
        Analysis result as a string
    """
    start_time = time.time()
    logger.info("Analyzing log with model: %smodel_name")

    # Create the prompt
    prompt = create_prompt(log_text, instruction)

    try:
        if model_name == "gpt4all":
            response = gpt4all_response(prompt)
        elif model_name == "openai":
            response = openai_response(prompt)
        elif model_name == "gemini":
            response = gemini_response(prompt)
        elif model_name == "huggingface":
            response = huggingface_response(prompt)
        else:
            return f"⚠ Error: Unknown model '{model_name}' specified"
    except Exception as e:
        logger.exception("Error analyzing log with %smodel_name: %sstr(e)")
        return f"⚠ Error analyzing log: {str(e)}"

    _elapsed_time = time.time() - start_time
    logger.info("Log analysis completed in %selapsed_time:.2f seconds")

    return response


def gpt4all_response(prompt: str) -> str:
    """Get a response from the GPT4All model.

    Args:
        prompt: The prompt to send to the model

    Returns:
        Model response as a string
    """
    model = initialize_gpt4all()
    if not model:
        raise ModelNotInitializedError("GPT4All model could not be initialized")

    try:
        logger.debug("Sending prompt to GPT4All (length: %slen(prompt))")
        response = ""

        # Use with context for proper resource handling
        with model.chat_session():
            # Stream response tokens for better performance monitoring
            for token in model.generate(prompt, max_tokens=2048, temp=0.7):
                response += token

        logger.debug("Received GPT4All response (length: %slen(response))")
        return response.strip()
    except Exception as e:
        logger.exception("Error with GPT4All: %sstr(e)")
        raise


def openai_response(prompt: str) -> str:
    """Get a response from the OpenAI API.

    Args:
        prompt: The prompt to send to the model

    Returns:
        Model response as a string
    """
    openai = initialize_openai()
    if not openai:
        raise ModelNotInitializedError("OpenAI API could not be initialized. Check your API key.")

    try:
        logger.debug("Sending prompt to OpenAI (length: %slen(prompt))")

        # Use the ChatCompletion API
        response = openai.ChatCompletion.create(
            model="gpt-4",

            messages=[
                {"role": "system", "content": "" +
                    "You are a log analysis expert. Provide clear, concise analysis of log files."},
                {"role": "user", "content": prompt}
            ],
            max_tokens=1024,
            temperature=0.5
        )

        response_text = response["choices"][0]["message"]["content"].strip()
        logger.debug("Received OpenAI response (length: %slen(response_text))")
        return response_text
    except Exception as e:
        logger.exception("Error with OpenAI: %sstr(e)")
        raise


def gemini_response(prompt: str) -> str:
    """Get a response from the Google Gemini API.

    Args:
        prompt: The prompt to send to the model

    Returns:
        Model response as a string
    """
    gemini = initialize_gemini()
    if not gemini:
        raise ModelNotInitializedError("Gemini API could not be initialized. Check your API key.")

    try:
        logger.debug("Sending prompt to Gemini (length: %slen(prompt))")
        model = gemini.GenerativeModel('gemini-pro')
        response = model.generate_content(prompt)

        response_text = response.text
        logger.debug("Received Gemini response (length: %slen(response_text))")
        return response_text.strip()
    except Exception as e:
        logger.exception("Error with Gemini: %sstr(e)")
        raise


def huggingface_response(prompt: str) -> str:
    """Get a response from the Hugging Face model.

    Args:
        prompt: The prompt to send to the model

    Returns:
        Model response as a string
    """
    model, tokenizer, pipe = initialize_huggingface()
    if not pipe:
        raise ModelNotInitializedError("Hugging Face model could not be initialized.")

    try:
        logger.debug("Sending prompt to Hugging Face (length: %slen(prompt))")

        # Generate text with appropriate parameters
        outputs = pipe(
            prompt,
            max_new_tokens=1024,
            temperature=0.7,
            top_p=0.95,
            repetition_penalty=1.15,
            do_sample=True
        )

        # Extract the generated text
        generated_text = outputs[0]['generated_text']

        # Remove the prompt from the response
        response_text = generated_text[len(prompt):].strip()

        logger.debug("Received Hugging Face response (length: %slen(response_text))")
        return response_text
    except Exception as e:
        logger.exception("Error with Hugging Face: %sstr(e)")
        raise


def get_available_models() -> List[Dict[str, Any]]:
    """Get information about available models.

    Returns:
        List of dictionaries with model information
    """
    models = []

    # Check GPT4All
    try:
        gpt4all = initialize_gpt4all()
        models.append({
            "name": "gpt4all",
            "available": gpt4all is not None,
            "type": "local",
            "file": LLAMA_MODEL_PATH
        })
    except (Exception, RuntimeError):
        models.append({
            "name": "gpt4all",
            "available": False,
            "type": "local",
            "error": "Failed to initialize"
        })

    # Check OpenAI
    models.append({
        "name": "openai",
        "available": OPENAI_API_KEY != "",
        "type": "api",
        "model": "gpt-4"
    })

    # Check Gemini
    models.append({
        "name": "gemini",
        "available": GEMINI_API_KEY != "",
        "type": "api",
        "model": "gemini-pro"
    })

    # Check Hugging Face
    try:
        _, _, pipe = initialize_huggingface()
        models.append({
            "name": "huggingface",
            "available": pipe is not None,
            "type": "local" if not HUGGINGFACE_API_KEY else "api",
            "model": HUGGINGFACE_MODEL_ID
        })
    except (Exception, RuntimeError):
        models.append({
            "name": "huggingface",
            "available": False,
            "type": "local",
            "error": "Failed to initialize"
        })

    return models


if __name__ == "__main__":
    # Simple test for the module
    models = get_available_models()
    print(json.dumps(models, indent=2))

    # Test a model if available
    for model_info in models:
        if model_info["available"]:
            model_name = model_info["name"]
            print(f"\nTesting {model_name} model...")

            TEST_LOG = "2023-05-01 12:34:56 ERROR Failed to connect to database: Connection refused"
            result = analyze_log(test_log, model_name)

            print(f"\nAnalysis result from {model_name}:")
            print(result)
            break (duplicate-code)
server/backend/ai_model.py:1:0: R0801: Similar lines in 2 files
==client.adjust_hierarchy_with_debugger:[18:70]
==devtools.adjust_hierarchy_with_debugger:[18:70]
    expected_structure = {
        'backend': {
            'backend': ['ai_model.py', 'app.py', 'backend.js', 'package-lock.json'],
            'frontend': ['config.py', 'index.html', 'main.js', 'package.json'],
            'models': [],
            'lib': ['libggml-base.so', 'libggml-cpu-alderlake.so'],
        },
        'logs': ['backend.log', 'frontend.log'],
        'readme': ['README.md']
    }

    # Helper function to create the directory structure
    def create_structure(target_path, structure):
        """Create directories and files based on expected structure."""
        for key, value in structure.items():
            target_dir = os.path.join(target_path, key)
            if isinstance(value, list):
                os.makedirs(target_dir, exist_ok=True)
                for file in value:
                    file_path = os.path.join(target_dir, file)
                    if not os.path.exists(file_path):
                        with open(file_path, 'w', encoding='utf-8') as f:
                            f.write('')
            elif isinstance(value, dict):
                os.makedirs(target_dir, exist_ok=True)
                create_structure(target_dir, value)

    # Create the directory structure
    create_structure(base_dir, expected_structure)
    print(f"Directory structure verified and restored in {base_dir}")


def run_pylint():
    """Run pylint with specific options to check the code."""
    try:
        result = subprocess.run(
            ['pylint', '--disable=all', '--enable=error'],
            capture_output=True,
            text=True,
            check=True
        )
        print(result.stdout)
        if result.stderr:
            print("Error:", result.stderr)
    except FileNotFoundError:
        print("Pylint is not installed. Install it with 'pip install pylint'.")


if __name__ == "__main__":
    BASE_DIR = '/home/zombie/ailinux'
    restore_directory_structure(base_dir)
    run_pylint() (duplicate-code)
server/backend/ai_model.py:1:0: R0801: Similar lines in 2 files
==client.analyze:[4:36]
==devtools.analyze:[4:36]
ROOT_DIR = "./"

# Ordner, die ausgeschlossen werden sollen
excluded_dirs = {"models", "__pycache__", "node_modules"}

# Log-Dateien ausschließen
excluded_files = {".log"}

# Pfad zur Logdatei
LOG_FILE_PATH = "project_code_analysis_1.log"

# Nur frontend- und backend-Verzeichnisse berücksichtigen
allowed_dirs = {"frontend", "backend"}

with open(log_file_path, "w", encoding='utf-8') as log_file:
    for root, dirs, files in os.walk(root_dir):
        # Filtere die Verzeichnisse, die ausgeschlossen werden sollen
        # und beschränke die Analyse auf frontend und backend
        dirs[:] = [d for d in dirs if d not in excluded_dirs and d in allowed_dirs]

        # Überprüfe, ob der aktuelle Pfad frontend oder backend ist
        current_dir = os.path.basename(root)
        if current_dir not in allowed_dirs:
            continue

        for file in files:
            # Nur .html-Dateien, keine Log-Dateien
            if file.endswith(".html") and not any(file.endswith(ext) for ext in excluded_files):
                file_path = os.path.join(root, file)
                with open(file_path, "r", encoding='utf-8') as f:
                    log_file.write(f"\n--- {file_path} ---\n")
                    log_file.write(f.read()) (duplicate-code)
server/backend/ai_model.py:1:0: R0801: Similar lines in 2 files
==client.adjust_hierarchy_with_debugger:[32:52]
==patch.ailinux-alpha-patch-v0.3:[152:170]
        for key, value in structure.items():
            target_dir = os.path.join(target_path, key)
            if isinstance(value, list):
                os.makedirs(target_dir, exist_ok=True)
                for file in value:
                    file_path = os.path.join(target_dir, file)
                    if not os.path.exists(file_path):
                        with open(file_path, 'w', encoding='utf-8') as f:
                            f.write('')
            elif isinstance(value, dict):
                os.makedirs(target_dir, exist_ok=True)
                create_structure(target_dir, value)

    # Create the directory structure
    create_structure(base_dir, expected_structure)
    print(f"Directory structure verified and restored in {base_dir}")


def run_pylint():
    """Run pylint with specific options to check the code.""" (duplicate-code)
server/backend/ai_model.py:1:0: R0801: Similar lines in 2 files
==client.adjust_hierarchy_with_debugger:[52:67]
==patch.ailinux-alpha-patch-v0.3:[172:187]
    try:
        result = subprocess.run(
            ['pylint', '--disable=all', '--enable=error'],
            capture_output=True,
            text=True,
            check=True
        )
        print(result.stdout)
        if result.stderr:
            print("Error:", result.stderr)
    except FileNotFoundError:
        print("Pylint is not installed. Install it with 'pip install pylint'.")


if __name__ == "__main__": (duplicate-code)
server/backend/ai_model.py:1:0: R0801: Similar lines in 2 files
==client.bigfiles:[4:24]
==devtools.bigfiles:[4:24]
DIRECTORY = '/home/zombie/ailinux'

# Verify the directory exists
if os.path.exists(directory):
    # Get all file paths and their sizes
    file_sizes = []
    for root, dirs, files in os.walk(directory):
        for file in files:
            file_path = os.path.join(root, file)
            file_size = os.path.getsize(file_path)
            file_sizes.append((file_path, file_size))

    # Sort by size in descending order
    file_sizes.sort(key=lambda x: x[1], reverse=True)

    # Show top 20 largest files
    top_20_files = file_sizes[:20]
    print(top_20_files)
else:
    print("Directory does not exist or cannot be accessed") (duplicate-code)
server/backend/ai_model.py:1:0: R0801: Similar lines in 2 files
==client.adjust_hierarchy_with_debugger:[18:32]
==patch.ailinux-alpha-patch-v0.3:[138:150]
    expected_structure = {
        'backend': {
            'backend': ['ai_model.py', 'app.py', 'backend.js', 'package-lock.json'],
            'frontend': ['config.py', 'index.html', 'main.js', 'package.json'],
            'models': [],
            'lib': ['libggml-base.so', 'libggml-cpu-alderlake.so'],
        },
        'logs': ['backend.log', 'frontend.log'],
        'readme': ['README.md']
    }

    # Helper function to create the directory structure
    def create_structure(target_path, structure):
        """Create directories and files based on expected structure.""" (duplicate-code)
server/backend/ai_model.py:1:0: R0801: Similar lines in 2 files
==client.adjust_hierarchy_with_debugger:[52:61]
==patch.ailinux-alpha-patch-v0.3:[33:42]
    try:
        result = subprocess.run(
            ['pylint', '--disable=all', '--enable=error'],
            capture_output=True,
            text=True,
            check=True
        )
        print(result.stdout)
        if result.stderr: (duplicate-code)
server/backend/ai_model.py:1:0: R0801: Similar lines in 2 files
==devtools.enhanced-pylint-fixer:[189:204]
==enhanced-pylint-fixer:[330:345]
            return False

    def fix_python_syntax_error(self, issue: PylintIssue) -> bool:
        """Fix Python-specific syntax errors."""
        lines = self.load_file(issue.file_path)
        if not lines:
            return False

        line_num = issue.line_num
        if line_num > len(lines):
            return False

        line = lines[line_num - 1]

        # Fix 1: String concatenation issues with '+" +' (duplicate-code)
server/backend/ai_model.py:1:0: R0801: Similar lines in 2 files
==enhanced-pylint-fixer:[292:307]
==patch.enhanced-pylint-fixer:[189:204]
            return False

    def fix_python_syntax_error(self, issue: PylintIssue) -> bool:
        """Fix Python-specific syntax errors."""
        lines = self.load_file(issue.file_path)
        if not lines:
            return False

        line_num = issue.line_num
        if line_num > len(lines):
            return False

        line = lines[line_num - 1]

        # Fix 1: String concatenation issues with '+" +' (duplicate-code)
server/backend/ai_model.py:1:0: R0801: Similar lines in 2 files
==enhanced-pylint-fixer:[189:204]
==patch.enhanced-pylint-fixer:[292:307]
            return False

    def fix_python_syntax_error(self, issue: PylintIssue) -> bool:
        """Fix Python-specific syntax errors."""
        lines = self.load_file(issue.file_path)
        if not lines:
            return False

        line_num = issue.line_num
        if line_num > len(lines):
            return False

        line = lines[line_num - 1]

        # Fix 1: String concatenation issues with '+" +' (duplicate-code)
server/backend/ai_model.py:1:0: R0801: Similar lines in 2 files
==devtools.enhanced-pylint-fixer:[375:393]
==enhanced-pylint-fixer:[328:338]
                return True

        return False

    def fix_trailing_whitespace(self, issue: PylintIssue) -> bool:
        """
        Remove trailing whitespace (C0303).

        Args:
            issue: The pylint issue to fix

        Returns:
            True if the issue was fixed, False otherwise
        """
        lines = self.load_file(issue.file_path)
        if not lines:
            return False
 (duplicate-code)
server/backend/ai_model.py:1:0: R0801: Similar lines in 2 files
==enhanced-pylint-fixer:[375:393]
==patch.enhanced-pylint-fixer:[290:300]
            return True

        return False

    def fix_javascript_syntax_error(self, issue: PylintIssue) -> bool:
        """Fix JavaScript-specific syntax errors."""
        lines = self.load_file(issue.file_path)
        if not lines:
            return False
 (duplicate-code)
server/backend/ai_model.py:1:0: R0801: Similar lines in 2 files
==enhanced-pylint-fixer:[328:345]
==patch.enhanced-pylint-fixer:[290:307]
                return True

        return False

    def fix_html_syntax_error(self, issue: PylintIssue) -> bool:
        """Fix HTML-specific syntax errors."""
        lines = self.load_file(issue.file_path)
        if not lines:
            return False

        line_num = issue.line_num
        if line_num > len(lines):
            return False

        line = lines[line_num - 1]

        # Fix "invalid decimal literal" - often caused by HTML attributes (duplicate-code)
server/backend/ai_model.py:1:0: R0801: Similar lines in 2 files
==enhanced-pylint-fixer:[290:300]
==patch.enhanced-pylint-fixer:[375:393]
                return True

        return False

    def fix_trailing_whitespace(self, issue: PylintIssue) -> bool:
        """
        Remove trailing whitespace (C0303).

        Args:
            issue: The pylint issue to fix

        Returns:
            True if the issue was fixed, False otherwise
        """
        lines = self.load_file(issue.file_path)
        if not lines:
            return False
 (duplicate-code)
server/backend/ai_model.py:1:0: R0801: Similar lines in 2 files
==enhanced-pylint-fixer:[290:307]
==patch.enhanced-pylint-fixer:[328:345]
                return True

        return False

    def fix_html_syntax_error(self, issue: PylintIssue) -> bool:
        """Fix HTML-specific syntax errors."""
        lines = self.load_file(issue.file_path)
        if not lines:
            return False

        line_num = issue.line_num
        if line_num > len(lines):
            return False

        line = lines[line_num - 1]

        # Fix "invalid decimal literal" - often caused by HTML attributes (duplicate-code)
server/backend/ai_model.py:1:0: R0801: Similar lines in 2 files
==enhanced-pylint-fixer:[614:623]
==patch.enhanced-pylint-fixer:[584:593]
            return False

        lines = self.load_file(issue.file_path)
        if not lines:
            return False

        line = lines[issue.line_num - 1]

        # Regular expression to find logging calls with f-strings (duplicate-code)
server/backend/ai_model.py:1:0: R0801: Similar lines in 2 files
==enhanced-pylint-fixer:[584:593]
==patch.enhanced-pylint-fixer:[614:623]
            return False

        lines = self.load_file(issue.file_path)
        if not lines:
            return False

        line = lines[issue.line_num - 1]

        # Check if it's a simple 'except:' or 'except Exception:' (duplicate-code)
server/backend/ai_model.py:1:0: R0801: Similar lines in 2 files
==enhanced-pylint-fixer:[518:527]
==patch.enhanced-pylint-fixer:[461:470]
            return False

        lines = self.load_file(issue.file_path)
        if not lines:
            return False

        line = lines[issue.line_num - 1]

        # Try to break the line if it's longer than the limit (duplicate-code)
server/backend/ai_model.py:1:0: R0801: Similar lines in 2 files
==enhanced-pylint-fixer:[461:470]
==patch.enhanced-pylint-fixer:[518:527]
            return False

        lines = self.load_file(issue.file_path)
        if not lines:
            return False

        line = lines[issue.line_num - 1]

        # Only fix Python files for docstrings (duplicate-code)
server/backend/ai_model.py:1:0: R0801: Similar lines in 2 files
==enhanced-pylint-fixer:[413:422]
==patch.enhanced-pylint-fixer:[377:394]
        return False

    def fix_trailing_whitespace(self, issue: PylintIssue) -> bool:
        """
        Remove trailing whitespace (C0303).

        Args:
            issue: The pylint issue to fix

        Returns:
            True if the issue was fixed, False otherwise
        """
        lines = self.load_file(issue.file_path)
        if not lines:
            return False

        line = lines[issue.line_num - 1] (duplicate-code)
server/backend/ai_model.py:1:0: R0801: Similar lines in 2 files
==enhanced-pylint-fixer:[377:394]
==patch.enhanced-pylint-fixer:[413:422]
        return False

    def fix_trailing_whitespace(self, issue: PylintIssue) -> bool:
        """
        Remove trailing whitespace (C0303).

        Args:
            issue: The pylint issue to fix

        Returns:
            True if the issue was fixed, False otherwise
        """
        lines = self.load_file(issue.file_path)
        if not lines:
            return False

        line = lines[issue.line_num - 1] (duplicate-code)

------------------------------------------------------------------
Your code has been rated at 6.85/10 (previous run: 0.00/10, +6.85)

